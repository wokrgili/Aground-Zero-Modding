<?xml version="1.0" encoding="utf-8" ?>
<data>
	<script>
	function getNearbyPlayer(o, maxdist){
		var a = o.area; if(a == null) return null; var min = maxdist*maxdist, best = null;
		for(p in a.getObjects(function(p){return p.health.get() > 0 &amp;&amp; p.isPlayer();}, makeBounds(o.getX()-maxdist, o.getY()-maxdist, o.getZ()-maxdist, maxdist*2, maxdist*2, maxdist*2))){
			var dx = o.getX()-p.getX(), dy = o.getY()-p.getY(), dz = (o.getZ()-p.getZ())*2;
			var v = dx*dx+dy*dy+dz*dz; if(v &lt; min){min = v; best = p;}
		} return best;
	}
	</script>
	<object id="base_enemy" ground="shadow" self="ENEMY" attack="0" defense="0" block="WORLD|PROJECTILE|STRUCTURE|BLUEPRINT|PLAYER|NPC|ENEMY" access="none">
		<infoInit>this.params.attack = eval(this.xml.get("attack")); this.params.defense = eval(this.xml.get("defense")); this.params.achievement = this.xml.get("achievement");</infoInit>
		<onDamage><script>this.flash(2,0,0,1,8);</script></onDamage>
		<onKilled><achievement eval="this.info.params.achievement" if="this.info.params.achievement != null && killer != null && killer.isPlayer()" /></onKilled>
	</object>
	<object id="wyrm" extends="base_enemy" model="wyrm" health="100" speed="0.033" modelBottom="true" mine="1" attack="10" defense="4" health_bar="Icon.fromTile(getTile('health_bar'),TYPE_EMISSIVE,3)" achievement="defeat_wyrm">
		<shape type="cylinder" y="1.25" radius="1.3" height="2.5" tilt="90" />
		<shape type="cylinder" y="-1.25" radius="1.3" height="2.5" tilt="90" />
		<transform>matrix.setScale(0.016,0.016,0.016); matrix.set(3, 1, 0.24);</transform>
		<infoInit>this.params.mine = eval(this.xml.get("mine"));</infoInit>
		<init><script>
		this.ground.color.alpha = 0.6; this.models[0].setAnimation("Armature|Worm_Crawl", true, null, 0.33, ANIM_TRANSITION); attack_ct = 0;
		attack_objects = []; attack_frames = 0; curSquish = 1.0;  function canAttack(o, cos, sin){
			var aabb = o.getAABB(); var len = 1.25+1.25*curSquish; var dx = this.getX()+len*cos-Utils.clamp(this.getX(), aabb.min_x, aabb.max_x);
			var dy = this.getY()+len*sin-Utils.clamp(this.getY(), aabb.min_y, aabb.max_y);
			var dist2 = dx*dx+dy*dy; return o.vars.get("can_target") != false &amp;&amp; o.health.get() > 0 &amp;&amp; getItemValue(o,"defense") &lt; this.info.params.attack &amp;&amp; dist2 &lt; 2;
		} stalled = 0.0; squishFrames = 0.0; function squish(f){
			if(f == curSquish) return; curSquish = f;
			this.body._shapeList._localTransform._positionY = f*1.25; this.body._shapeList._next._localTransform._positionY = -f*1.25; this.body._shapeModified();
			this.modelTransform.set(1,1,this.info.modelTransform.get(1,1)*(0.5+f*0.5)); this.updateTransform();
		} function rotateSquish(frames){
			this.body.setType(BODY_STATIC); maxSquishFrames = frames; squishFrames = maxSquishFrames; stalled = 0.0;
		} function facePos(rot,x,y){
			var dx = x-this.getX(); var dy = y-this.getY(); var nr = 0.0;
			var adx = Math.abs(dx), ady = Math.abs(dy);
			if(adx > ady){if(ady > adx*0.5) return; nr = getAngle(rot.z,Utils.sign(dx)*PI/2);}
			else {if(adx > ady*0.5) return; nr = getAngle(rot.z,PI/2+Utils.sign(dy)*PI/2);}
			if(Math.abs(nr-rot.z) > 0.1){this.lerp(new RotateKeyframe(rot.x, rot.y, nr), 30); rotateSquish(30); return true;} else return false;
		} bounds = makeBounds(0,0,0,0,0,0); dig_time = time(); var tmp = new Point(); var out = new Point();
		function onAttack(attack, point, projectile, projectileData){
			if(projectile != null){
				var p = this.getViewDir(); tmp.set(projectile.velX, projectile.velY, projectile.velZ); var len = tmp.length(); tmp.scaleBy(1.0/len);
				if(Point.dot(p, tmp) &lt; -0.7){
					out.copy(point); out.x -= this.getX(); out.y -= this.getY(); out.z -= this.getZ();
					if(Point.dot(p, out)*1.05 >= (1.25+1.25*curSquish)) return attack-getItemValue(this, "defense");
				} Point.reflect(tmp, projectileData.normal, out); projectile.filter = this.notSelf;
				out.scaleBy(len*0.5); projectile.velX = out.x; projectile.velY = out.y; projectile.velZ = out.z;
				projectile.scale_decay = 0; projectile.decay = 0; projectile.alpha = 1; facePos(this.getRotation(),point.x,point.y); return 0;
			} return attack-getItemValue(this, "defense");
		}
		</script></init>
		<onFrame>
		if(squishFrames > 0){squishFrames -= frames; squish(Math.max(curSquish-frames/maxSquishFrames,0.0));}
		var rot = this.getRotation(); var r = rot.z-PI/2; var cos = Math.cos(r); var sin = Math.sin(r);
		if(attack_objects.length > 0){
			attack_frames -= frames; if(attack_frames &lt; 0){
				for(o in attack_objects) if(canAttack(o, cos, sin)){
					playSoundAt(o.area, o, "pierced");
					attack(o, this, this.info.params.attack, new Point(this.getX(), this.getY(), this.getZ()), null, null);
				} Utils.clear(attack_objects); attack_ct = 0;
			} return;
		} if(this.health.get() == 0 || this.models[0].isAnimating() || this.hasFacePos()) return;
		if(this.body._type == BODY_STATIC){this.body.setType(BODY_DYNAMIC); return;}
		var dx = Math.round(cos); var dy = Math.round(sin); var eat = 0; var atk = 0;
		var len = 1.25+1.25*curSquish;
		if(attack_ct &lt;= 0){
			attack_ct += 30;
			bounds.set(this.getX()+len*cos-1.3, this.getY()+len*sin-1.3, this.getZ()-1.3, 2.6, 2.6, 2.6); for(o in this.area.getObjects(function(o){return o.info.id != "wyrm" &amp;&amp; canAttack(o, cos, sin);}, bounds)){
				attack_objects.push(o); atk++;
			} if(atk > 0){attack_frames = 15; playSoundAt(this.area, this, "wyrm_attack"); this.models[0].setAnimation("Armature|Worm_Attack", false, null, 0.33, ANIM_TRANSITION, true); return;}
			var o = getNearbyPlayer(this, 9); if(o != null) facePos(rot,o.getX(),o.getY());
		} else attack_ct -= frames;
		var b = this.getAABB(); var sz = Math.round(b.min_z); var ez = Math.ceil(b.max_z); var mval = 0, eaten = 0;
		if(dx == 0){
			var sx = Math.floor(b.min_x); var ex = Math.ceil(b.max_x); var y = dy > 0?Math.ceil(b.max_y+0.1):Math.floor(b.min_y-0.1);
			for(z in sz...ez) for(x in sx...ex) if(Action.getStructureOnTile(area, x, y, z) == null &amp;&amp;
				(mval = Action.mineTile(this.area, this, x, y, z, this.info.params.mine, frames, false)) >= -1){if(mval > 0) eaten++; eat++;}
		} else {
			var sy = Math.floor(b.min_y); var ey = Math.ceil(b.max_y); var x = dx > 0?Math.ceil(b.max_x+0.1):Math.floor(b.min_x-0.1);
			for(z in sz...ez) for(y in sy...ey) if(Action.getStructureOnTile(area, x, y, z) == null &amp;&amp;
				(mval = Action.mineTile(this.area, this, x, y, z, this.info.params.mine, frames, false)) >= -1){if(mval > 0) eaten++; eat++;}
		} if(eaten > 0) playSoundAt(this.area, this, "break", false, 1, 2);
		if(eat > 0){
			this.models[0].setAnimation("Armature|Worm_Attack", true, null, 0.33, ANIM_TRANSITION);
			var t = time(); if(t > dig_time+1 &amp;&amp; this.models[0].animation.animations[0].currentFrame == 0){dig_time = t; playSoundAt(this.area, this, "wyrm_dig");}
		} else {
			var v = vec3(0,0,0); this.body.getLinearVelocityTo(v); v.z = 0; var len = v.length();
			if(len &lt;= 0.1){squish(Math.max(0.0,curSquish-frames/15.0)); stalled += frames;} else if(curSquish &lt; 1.0) squish(Math.min(1.0,curSquish+frames/15.0)); if(stalled > 30){
				this.lerp(new RotateKeyframe(rot.x, rot.y, getAngle(rot.z,r-PI/2)), 30); rotateSquish(30); return;
			} this.models[0].setAnimation("Armature|Worm_Crawl", true, null, 0.33, ANIM_TRANSITION); this.move(dx, dy, 0, frames, 1+Utils.clamp(3-len, 0, 2), 10);
		}
		</onFrame>
		<onHit><script>facePos(this.getRotation(),point.x,point.y)</script></onHit>
		<onDeath><script>playSoundAt(this.area, vec3(this.getX(), this.getY(), this.getZ()), "wyrm_death"); this.models[0].setAnimation("Armature|Worm_Death", false, null, 0.33, ANIM_TRANSITION); this.lerp(new ModelScaleKeyframe(0.125,0.125,0.125), 90, function(){this.dropItem(makeItem('dragonblood', 3), 0.25); this.remove();});</script></onDeath>
	</object>
	<object id="bat" extends="base_enemy" model="bat" health="10" speed="0.033" modelBottom="true" attack="1" ground="" health_bar="Icon.fromTile(getTile('health_bar'),TYPE_EMISSIVE,0.6)" achievement="defeat_bat">
		<shape type="capsule" radius="0.25" height="0.2" />
		<transform>matrix.setScale(0.006,0.006,0.006); matrix.set(3,2,-0.1);</transform>
		<init><script>
			if(this.getRotation().x == PI){this.models[0].setAnimation("perch", false, null, 1, ANIM_TRANSITION); this.models[0].step(9999);} else this.models[0].setAnimation("fly", true, null, 1, ANIM_TRANSITION); this.body.setGravityScale(0);
			function doPerch(){this.models[0].setAnimation("perch", false, null, 1, ANIM_TRANSITION);}
			unperchDir = 0.0; runFrames = 0.0; stalled = 0.0; attackFrames = 0.0; attack_frames = 0;
			function idle(){this.models[0].setAnimation("fly", true, null, 1, ANIM_TRANSITION);}
			function unperch2(){this.lerp(new RotateKeyframe(0,0,unperchDir), 10, idle);}
			function unperch(){this.models[0].setAnimation("perch", false, unperch2, -1, ANIM_TRANSITION);}
			function runAway(){
				if(runFrames &lt;= 50) playSoundAt(this.area, this, "bat_squeak");
				target = null; runFrames = 200; if(this.hasFacePos() || this.models[0].isAnimating()) return;
				var rot = this.getRotation(); unperchDir = PI-rot.z; if(rot.x == PI) unperch(); else unperch2();
			}
			function canAttack(o){
				return (o.info.self&amp;(PLAYER|NPC)) != 0 &amp;&amp; o.health.get() > 0 &amp;&amp; getItemValue(o,"defense") &lt; this.info.params.attack;
			} bounds = makeBounds(0,0,0,0,0,0); seek_radius = 7; from = new Point(); target = null;
		</script></init>
		<onFrame>
		if(target != null &amp;&amp; attack_frames > 0){
			attack_frames -= frames; if(attack_frames &lt; 0){
				var dx = target.getX()-this.getX(), dy = target.getY()-this.getY(), dz = target.getZ()-this.getZ();
				if(dx*dx+dy*dy+dz*dz &lt; 1 &amp;&amp; canAttack(target)){
					playSoundAt(target.area, target, "pierced");
					attack(target, this, this.info.params.attack, new Point(this.getX(), this.getY(), this.getZ()), null, null);
				} target = null;
			} return;
		} if(this.hasFacePos() || this.models[0].isAnimating()) return;
		var rot = this.getRotation(), pan = rot.z, isPerch = rot.x == PI;
		if(target != null){
			var dx = target.getX()-this.getX(), dy = target.getY()-this.getY();
			if(isPerch || dx*dx+dy*dy > seek_radius*seek_radius || !canAttack(target)) target = null; else {
				var v = vec3(0,0,0); this.body.getLinearVelocityTo(v); var len = v.length();
				if(len &lt;= 0.1) stalled += frames; if(stalled > 30) target = null; else {
					this.setRotation(0,0,getAngle(pan, Math.atan2(dy, dx)-PI/2));
					this.move(dx, dy, target.getZ()+0.25-this.getZ(), frames, 1); return;
				}
			}
		} if(attackFrames > 0) attackFrames -= frames; else {
			bounds.set(this.getX()-seek_radius, this.getY()-seek_radius, this.getZ()-seek_radius, seek_radius*2, seek_radius*2, seek_radius*2);
			for(o in this.area.getObjects(canAttack, bounds)){
				from.copy(this.getPosition()); if(this.area.raytrace(true, function(b){return b != this &amp;&amp; b != o;}, from, o.getPosition(), ENEMY) >= 1){
					target = o; var dx = o.getX()-this.getX(), dy = o.getY()-this.getY(); stalled = 0; runFrames = 0;
					unperchDir = getAngle(pan, Math.atan2(dy, dx)-PI/2); if(isPerch) unperch(); else unperch2(); return;
				}
			} attackFrames = 100;
		} if(isPerch){if(!onGround(this.body, 1)) runAway(); return;} var dz = 0.5;
		if(runFrames > 0){
			var v = vec3(0,0,0); this.body.getLinearVelocityTo(v); var len = v.length();
			if(len &lt;= 1) stalled += frames; if(stalled > 10){this.lerp(new RotateKeyframe(0,0,pan+random()*PI+PI/2), 10); stalled = 0;}
			runFrames -= frames; if(onGround(this.body, 1)) dz = -0.1;
		} else if(onGround(this.body, 1)){
			this.lerp(new RotateKeyframe(PI,0,PI-pan), 10, doPerch); return;
		} var view = this.getViewDir();
		this.move(-view.x, -view.y, dz, frames, 1);
		</onFrame>
		<beginContact>if(object == target &amp;&amp; runFrames &lt;= 0){
			attack_frames = 5; attackFrames = 1000; runFrames = 200; this.models[0].setAnimation("bite", false, idle, 1, ANIM_TRANSITION, true);
		} else if(target == null) runAway();</beginContact>
		<beginItemContact>runAway();</beginItemContact>
		<onHit><script>runAway();</script></onHit>
		<footstep><script if="type == 0 && this.area != null">playSoundAt(this.area, this, "flap")</script></footstep>
		<onDeath><script>this.body.setGravityScale(1); playSoundAt(this.area, vec3(this.getX(), this.getY(), this.getZ()), "bat_death"); this.models[0].setAnimation("death", false, null, 1, ANIM_TRANSITION); this.lerp(new ModelScaleKeyframe(0.25,0.25,0.25), 30, function(){this.dropItem(makeItem('meat', 1), 0.25); this.remove();});</script></onDeath>
	</object>
</data>